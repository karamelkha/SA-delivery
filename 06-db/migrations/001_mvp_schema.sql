-- Delivery MVP schema (PostgreSQL 14+)
-- Purpose:
-- 1) enforce single succeeded payment per order (partial unique index)
-- 2) enforce address ownership via composite FK
-- 3) enforce "one role per user account" via trigger
-- 4) standardize all time fields as TIMESTAMPTZ (UTC operational standard)

BEGIN;

-- Session-level UTC for migration execution.
SET TIME ZONE 'UTC';

-- =========================
-- Domain enums
-- =========================
CREATE TYPE order_status_t AS ENUM (
    'WAITING_PAYMENT',
    'UNPAID',
    'PAID',
    'RESTAURANT_CONFIRMED',
    'REJECTED',
    'READY_FOR_DELIVERY',
    'WAITING_COURIER_ASSIGNMENT',
    'COURIER_NOT_ASSIGNED',
    'IN_TRANSIT',
    'DELIVERED',
    'CANCELLED'
);

CREATE TYPE payment_status_t AS ENUM (
    'PAYMENT_PENDING',
    'PAYMENT_SUCCEEDED',
    'PAYMENT_FAILED',
    'PAYMENT_TIMED_OUT'
);

CREATE TYPE refund_status_t AS ENUM (
    'REFUND_REQUIRED',
    'REFUND_IN_PROGRESS',
    'REFUND_COMPLETED',
    'REFUND_FAILED'
);

CREATE TYPE actor_role_t AS ENUM (
    'Customer',
    'Restaurant',
    'Courier',
    'Administrator',
    'System'
);

CREATE TYPE account_status_t AS ENUM (
    'ACTIVE',
    'BLOCKED',
    'DISABLED',
    'DELETED'
);

CREATE TYPE auth_provider_t AS ENUM (
    'LOCAL',
    'EXTERNAL'
);

CREATE TYPE integration_direction_t AS ENUM (
    'OUTBOUND',
    'INBOUND'
);

CREATE TYPE integration_message_type_t AS ENUM (
    'PAYMENT_RESULT',
    'REFUND_REQUIRED',
    'REFUND_RESULT'
);

CREATE TYPE integration_processing_status_t AS ENUM (
    'RECEIVED',
    'PENDING',
    'PROCESSED',
    'FAILED',
    'DLQ'
);

-- =========================
-- Core account and role tables
-- =========================
CREATE TABLE user_account (
    user_account_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    login                VARCHAR(120) NOT NULL UNIQUE,
    password_hash        VARCHAR(255),
    auth_provider        auth_provider_t NOT NULL,
    external_subject_id  VARCHAR(128),
    account_status       account_status_t NOT NULL DEFAULT 'ACTIVE',
    failed_login_attempts INTEGER NOT NULL DEFAULT 0 CHECK (failed_login_attempts >= 0),
    blocked_until        TIMESTAMPTZ,
    last_login_at        TIMESTAMPTZ,
    created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
    deactivated_at       TIMESTAMPTZ,
    CONSTRAINT uq_user_account_external_subject UNIQUE (external_subject_id),
    CONSTRAINT ck_user_account_provider_password
        CHECK (
            (auth_provider = 'LOCAL' AND password_hash IS NOT NULL)
            OR
            (auth_provider = 'EXTERNAL')
        )
);

CREATE TABLE customer (
    customer_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_account_id    BIGINT NOT NULL UNIQUE REFERENCES user_account(user_account_id),
    full_name          VARCHAR(200) NOT NULL,
    phone              VARCHAR(20) NOT NULL UNIQUE,
    email              VARCHAR(254) UNIQUE,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE restaurant (
    restaurant_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_account_id    BIGINT NOT NULL UNIQUE REFERENCES user_account(user_account_id),
    name               VARCHAR(255) NOT NULL,
    address            VARCHAR(500) NOT NULL,
    phone              VARCHAR(20) NOT NULL,
    is_open            BOOLEAN NOT NULL DEFAULT TRUE,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE courier (
    courier_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_account_id    BIGINT NOT NULL UNIQUE REFERENCES user_account(user_account_id),
    full_name          VARCHAR(200) NOT NULL,
    phone              VARCHAR(20) NOT NULL UNIQUE,
    courier_status     VARCHAR(32) NOT NULL,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE administrator (
    admin_id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_account_id    BIGINT NOT NULL UNIQUE REFERENCES user_account(user_account_id),
    full_name          VARCHAR(200) NOT NULL,
    email              VARCHAR(254) NOT NULL UNIQUE,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE customer_address (
    address_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id        BIGINT NOT NULL REFERENCES customer(customer_id),
    label              VARCHAR(100) NOT NULL,
    full_address       VARCHAR(500) NOT NULL,
    comment            VARCHAR(500),
    is_default         BOOLEAN NOT NULL DEFAULT FALSE,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT uq_customer_address_owner UNIQUE (customer_id, address_id)
);

-- =========================
-- Ordering and delivery
-- =========================
CREATE TABLE orders (
    order_id                         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id                      BIGINT NOT NULL REFERENCES customer(customer_id),
    restaurant_id                    BIGINT NOT NULL REFERENCES restaurant(restaurant_id),
    delivery_address_id              BIGINT NOT NULL,
    courier_id                       BIGINT REFERENCES courier(courier_id),
    order_status                     order_status_t NOT NULL,
    current_payment_status           payment_status_t NOT NULL,
    current_payment_id               BIGINT,
    total_amount                     NUMERIC(10,2) NOT NULL CHECK (total_amount >= 0),
    currency                         CHAR(3) NOT NULL,
    payment_deadline_at              TIMESTAMPTZ NOT NULL,
    courier_assignment_deadline_at   TIMESTAMPTZ,
    next_assignment_attempt_at       TIMESTAMPTZ,
    version                          BIGINT NOT NULL DEFAULT 0,
    created_at                       TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at                       TIMESTAMPTZ NOT NULL DEFAULT now(),
    closed_at                        TIMESTAMPTZ,
    CONSTRAINT fk_order_delivery_address_owner
        FOREIGN KEY (customer_id, delivery_address_id)
        REFERENCES customer_address(customer_id, address_id)
);

CREATE TABLE menu_item (
    menu_item_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    restaurant_id        BIGINT NOT NULL REFERENCES restaurant(restaurant_id),
    name                 VARCHAR(255) NOT NULL,
    description          VARCHAR(1000),
    price                NUMERIC(10,2) NOT NULL CHECK (price >= 0),
    currency             CHAR(3) NOT NULL,
    is_available         BOOLEAN NOT NULL DEFAULT TRUE,
    created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at           TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE order_item (
    order_item_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id             BIGINT NOT NULL REFERENCES orders(order_id),
    menu_item_id         BIGINT NOT NULL REFERENCES menu_item(menu_item_id),
    item_name_snapshot   VARCHAR(255) NOT NULL,
    unit_price           NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
    quantity             INTEGER NOT NULL CHECK (quantity > 0),
    line_total           NUMERIC(10,2) NOT NULL CHECK (line_total >= 0),
    created_at           TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- =========================
-- Payments and refunds
-- =========================
CREATE TABLE payment_attempt (
    payment_id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id              BIGINT NOT NULL REFERENCES orders(order_id),
    attempt_no            INTEGER NOT NULL CHECK (attempt_no > 0),
    payment_status        payment_status_t NOT NULL,
    amount                NUMERIC(10,2) NOT NULL CHECK (amount >= 0),
    currency              CHAR(3) NOT NULL,
    payment_provider      VARCHAR(100) NOT NULL,
    provider_payment_id   VARCHAR(128),
    provider_result_code  VARCHAR(64),
    provider_event_id     VARCHAR(128),
    idempotency_key       VARCHAR(128),
    requested_at          TIMESTAMPTZ NOT NULL,
    result_received_at    TIMESTAMPTZ,
    expires_at            TIMESTAMPTZ NOT NULL,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT uq_payment_attempt_no UNIQUE (order_id, attempt_no),
    CONSTRAINT uq_payment_attempt_provider_payment_id UNIQUE (provider_payment_id),
    CONSTRAINT uq_payment_attempt_provider_event_id UNIQUE (provider_event_id)
);

ALTER TABLE orders
    ADD CONSTRAINT fk_order_current_payment
    FOREIGN KEY (current_payment_id)
    REFERENCES payment_attempt(payment_id);

CREATE TABLE refund_request (
    refund_request_id     VARCHAR(64) PRIMARY KEY,
    order_id              BIGINT NOT NULL UNIQUE REFERENCES orders(order_id),
    payment_id            BIGINT NOT NULL REFERENCES payment_attempt(payment_id),
    reason_code           VARCHAR(64) NOT NULL,
    refund_status         refund_status_t NOT NULL,
    amount                NUMERIC(10,2) NOT NULL CHECK (amount >= 0),
    provider_refund_id    VARCHAR(128) UNIQUE,
    last_error_code       VARCHAR(64),
    last_error_message    VARCHAR(500),
    initiated_at          TIMESTAMPTZ NOT NULL,
    processed_at          TIMESTAMPTZ,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at            TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- =========================
-- Audit and integration
-- =========================
CREATE TABLE order_history_event (
    event_id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id              BIGINT NOT NULL REFERENCES orders(order_id),
    event_type            VARCHAR(64) NOT NULL,
    actor_role            actor_role_t NOT NULL,
    actor_id              BIGINT,
    previous_value        VARCHAR(128),
    new_value             VARCHAR(128),
    reason_code           VARCHAR(64),
    description           VARCHAR(500),
    correlation_id        UUID NOT NULL,
    event_payload_json    JSONB,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE idempotency_record (
    idempotency_record_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    idempotency_key       VARCHAR(128) NOT NULL,
    operation_name        VARCHAR(100) NOT NULL,
    actor_role            actor_role_t NOT NULL,
    actor_id              BIGINT,
    request_hash          CHAR(64) NOT NULL,
    response_status_code  INTEGER NOT NULL,
    response_body_json    JSONB NOT NULL,
    resource_type         VARCHAR(64),
    resource_id           VARCHAR(64),
    expires_at            TIMESTAMPTZ NOT NULL,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT uq_idempotency_key_scope
        UNIQUE (operation_name, actor_role, actor_id, idempotency_key)
);

CREATE TABLE integration_message (
    integration_message_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    direction              integration_direction_t NOT NULL,
    message_type           integration_message_type_t NOT NULL,
    external_event_id      VARCHAR(128),
    order_id               BIGINT REFERENCES orders(order_id),
    payment_id             BIGINT REFERENCES payment_attempt(payment_id),
    refund_request_id      VARCHAR(64) REFERENCES refund_request(refund_request_id),
    correlation_id         UUID NOT NULL,
    payload_json           JSONB NOT NULL,
    processing_status      integration_processing_status_t NOT NULL,
    retry_count            INTEGER NOT NULL DEFAULT 0 CHECK (retry_count >= 0),
    next_retry_at          TIMESTAMPTZ,
    last_error             VARCHAR(500),
    created_at             TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at             TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE user_account_audit (
    user_account_audit_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_account_id       BIGINT NOT NULL REFERENCES user_account(user_account_id),
    event_type            VARCHAR(64) NOT NULL,
    actor_role            actor_role_t NOT NULL,
    actor_id              BIGINT,
    previous_value        VARCHAR(128),
    new_value             VARCHAR(128),
    reason_code           VARCHAR(64),
    correlation_id        UUID NOT NULL,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- =========================
-- Required indexes and constraints
-- =========================
CREATE INDEX ix_orders_status_created_at ON orders(order_status, created_at);
CREATE INDEX ix_orders_customer_created_at ON orders(customer_id, created_at);
CREATE INDEX ix_orders_restaurant_status ON orders(restaurant_id, order_status);
CREATE INDEX ix_orders_courier_status ON orders(courier_id, order_status);
CREATE INDEX ix_orders_payment_deadline ON orders(payment_deadline_at);
CREATE INDEX ix_orders_courier_assignment_deadline ON orders(courier_assignment_deadline_at);

CREATE INDEX ix_payment_attempt_order_attempt_no ON payment_attempt(order_id, attempt_no);
CREATE INDEX ix_payment_attempt_provider_event_id ON payment_attempt(provider_event_id);
CREATE UNIQUE INDEX ux_payment_attempt_one_succeeded_per_order
    ON payment_attempt(order_id)
    WHERE payment_status = 'PAYMENT_SUCCEEDED';

CREATE INDEX ix_refund_request_order_id ON refund_request(order_id);
CREATE INDEX ix_order_history_event_order_created ON order_history_event(order_id, created_at);
CREATE INDEX ix_integration_message_status_next_retry ON integration_message(processing_status, next_retry_at);
CREATE INDEX ix_user_account_audit_account_created ON user_account_audit(user_account_id, created_at);

-- =========================
-- Updated_at auto-maintenance
-- =========================
CREATE OR REPLACE FUNCTION fn_set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at := now();
    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_user_account_set_updated_at
BEFORE UPDATE ON user_account
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_customer_set_updated_at
BEFORE UPDATE ON customer
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_restaurant_set_updated_at
BEFORE UPDATE ON restaurant
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_courier_set_updated_at
BEFORE UPDATE ON courier
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_administrator_set_updated_at
BEFORE UPDATE ON administrator
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_customer_address_set_updated_at
BEFORE UPDATE ON customer_address
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_orders_set_updated_at
BEFORE UPDATE ON orders
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_menu_item_set_updated_at
BEFORE UPDATE ON menu_item
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_payment_attempt_set_updated_at
BEFORE UPDATE ON payment_attempt
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_refund_request_set_updated_at
BEFORE UPDATE ON refund_request
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

CREATE TRIGGER trg_integration_message_set_updated_at
BEFORE UPDATE ON integration_message
FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();

-- =========================
-- One-role-per-account (MVP) enforcement
-- =========================
CREATE OR REPLACE FUNCTION fn_enforce_single_role_per_account()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    v_exists boolean;
BEGIN
    -- Ignore no-op updates.
    IF TG_OP = 'UPDATE' AND NEW.user_account_id = OLD.user_account_id THEN
        RETURN NEW;
    END IF;

    SELECT EXISTS (
        SELECT 1
        FROM (
            SELECT 'customer' AS role_table, user_account_id FROM customer
            UNION ALL
            SELECT 'restaurant' AS role_table, user_account_id FROM restaurant
            UNION ALL
            SELECT 'courier' AS role_table, user_account_id FROM courier
            UNION ALL
            SELECT 'administrator' AS role_table, user_account_id FROM administrator
        ) roles
        WHERE roles.user_account_id = NEW.user_account_id
          AND roles.role_table <> TG_TABLE_NAME
    )
    INTO v_exists;

    IF v_exists THEN
        RAISE EXCEPTION 'user_account_id % is already bound to another role table', NEW.user_account_id
            USING ERRCODE = '23514';
    END IF;

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_customer_single_role
BEFORE INSERT OR UPDATE OF user_account_id ON customer
FOR EACH ROW EXECUTE FUNCTION fn_enforce_single_role_per_account();

CREATE TRIGGER trg_restaurant_single_role
BEFORE INSERT OR UPDATE OF user_account_id ON restaurant
FOR EACH ROW EXECUTE FUNCTION fn_enforce_single_role_per_account();

CREATE TRIGGER trg_courier_single_role
BEFORE INSERT OR UPDATE OF user_account_id ON courier
FOR EACH ROW EXECUTE FUNCTION fn_enforce_single_role_per_account();

CREATE TRIGGER trg_administrator_single_role
BEFORE INSERT OR UPDATE OF user_account_id ON administrator
FOR EACH ROW EXECUTE FUNCTION fn_enforce_single_role_per_account();

-- Active account must be bound to exactly one role profile (MVP policy).
CREATE OR REPLACE FUNCTION fn_validate_active_account_has_role()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    v_has_role boolean;
BEGIN
    IF NEW.account_status <> 'ACTIVE' THEN
        RETURN NULL;
    END IF;

    SELECT EXISTS (
        SELECT 1
        FROM (
            SELECT user_account_id FROM customer
            UNION ALL
            SELECT user_account_id FROM restaurant
            UNION ALL
            SELECT user_account_id FROM courier
            UNION ALL
            SELECT user_account_id FROM administrator
        ) roles
        WHERE roles.user_account_id = NEW.user_account_id
    )
    INTO v_has_role;

    IF NOT v_has_role THEN
        RAISE EXCEPTION 'ACTIVE user_account_id % must have exactly one role profile', NEW.user_account_id
            USING ERRCODE = '23514';
    END IF;

    RETURN NULL;
END;
$$;

CREATE CONSTRAINT TRIGGER ctrg_user_account_active_has_role
AFTER INSERT OR UPDATE OF account_status ON user_account
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION fn_validate_active_account_has_role();

CREATE OR REPLACE FUNCTION fn_validate_account_role_binding_after_profile_change()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_account_id BIGINT;
    v_account_status account_status_t;
    v_has_role boolean;
BEGIN
    v_user_account_id := COALESCE(OLD.user_account_id, NEW.user_account_id);

    IF v_user_account_id IS NULL THEN
        RETURN NULL;
    END IF;

    SELECT account_status
      INTO v_account_status
      FROM user_account
     WHERE user_account_id = v_user_account_id;

    IF v_account_status <> 'ACTIVE' THEN
        RETURN NULL;
    END IF;

    SELECT EXISTS (
        SELECT 1
        FROM (
            SELECT user_account_id FROM customer
            UNION ALL
            SELECT user_account_id FROM restaurant
            UNION ALL
            SELECT user_account_id FROM courier
            UNION ALL
            SELECT user_account_id FROM administrator
        ) roles
        WHERE roles.user_account_id = v_user_account_id
    )
    INTO v_has_role;

    IF NOT v_has_role THEN
        RAISE EXCEPTION 'ACTIVE user_account_id % must remain bound to one role profile', v_user_account_id
            USING ERRCODE = '23514';
    END IF;

    RETURN NULL;
END;
$$;

CREATE CONSTRAINT TRIGGER ctrg_customer_profile_binding
AFTER INSERT OR UPDATE OF user_account_id OR DELETE ON customer
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION fn_validate_account_role_binding_after_profile_change();

CREATE CONSTRAINT TRIGGER ctrg_restaurant_profile_binding
AFTER INSERT OR UPDATE OF user_account_id OR DELETE ON restaurant
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION fn_validate_account_role_binding_after_profile_change();

CREATE CONSTRAINT TRIGGER ctrg_courier_profile_binding
AFTER INSERT OR UPDATE OF user_account_id OR DELETE ON courier
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION fn_validate_account_role_binding_after_profile_change();

CREATE CONSTRAINT TRIGGER ctrg_administrator_profile_binding
AFTER INSERT OR UPDATE OF user_account_id OR DELETE ON administrator
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION fn_validate_account_role_binding_after_profile_change();

COMMIT;
